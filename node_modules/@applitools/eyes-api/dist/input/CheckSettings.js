"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckSettingsFluent = void 0;
const utils = __importStar(require("@applitools/utils"));
const AccessibilityRegionType_1 = require("../enums/AccessibilityRegionType");
const MatchLevel_1 = require("../enums/MatchLevel");
class CheckSettingsFluent {
    constructor(settings, spec) {
        this._settings = {};
        if (!settings)
            return this;
        if (utils.types.instanceOf(settings, CheckSettingsFluent))
            return settings;
        this._spec = spec;
        if (settings.name)
            this.name(settings.name);
        if (settings.region)
            this.region(settings.region);
        if (settings.scrollRootElement)
            this.scrollRootElement(settings.scrollRootElement);
        if (settings.frames) {
            settings.frames.forEach(reference => {
                if (!utils.types.isNull(reference))
                    this.frame(reference);
            });
        }
        if (!utils.types.isNull(settings.fully))
            this.fully(settings.fully);
        if (settings.matchLevel)
            this.matchLevel(settings.matchLevel);
        if (!utils.types.isNull(settings.useDom))
            this.useDom(settings.useDom);
        if (!utils.types.isNull(settings.sendDom))
            this.sendDom(settings.sendDom);
        if (!utils.types.isNull(settings.enablePatterns))
            this.enablePatterns(settings.enablePatterns);
        if (!utils.types.isNull(settings.ignoreDisplacements))
            this.ignoreDisplacements(settings.ignoreDisplacements);
        if (!utils.types.isNull(settings.ignoreCaret))
            this.ignoreCaret(settings.ignoreCaret);
        if (settings.ignoreRegions) {
            settings.ignoreRegions.forEach(ignoreRegion => this.ignoreRegion(ignoreRegion));
        }
        if (settings.layoutRegions) {
            settings.layoutRegions.forEach(layoutRegion => this.layoutRegion(layoutRegion));
        }
        if (settings.strictRegions) {
            settings.strictRegions.forEach(strictRegion => this.strictRegion(strictRegion));
        }
        if (settings.contentRegions) {
            settings.contentRegions.forEach(contentRegion => this.contentRegion(contentRegion));
        }
        if (settings.floatingRegions) {
            settings.floatingRegions.forEach(floatingRegion => this.floatingRegion(floatingRegion));
        }
        if (settings.accessibilityRegions) {
            settings.accessibilityRegions.forEach(accessibilityRegion => this.accessibilityRegion(accessibilityRegion));
        }
        if (!utils.types.isNull(settings.disableBrowserFetching))
            this.disableBrowserFetching(settings.disableBrowserFetching);
        if (!utils.types.isNull(settings.layoutBreakpoints))
            this.layoutBreakpoints(settings.layoutBreakpoints);
        if (settings.hooks) {
            Object.entries(settings.hooks).forEach(([name, script]) => this.hook(name, script));
        }
        if (settings.visualGridOptions) {
            Object.entries(settings.visualGridOptions).forEach(([key, value]) => this.visualGridOption(key, value));
        }
        if (settings.renderId)
            this.renderId(settings.renderId);
        if (settings.pageId)
            this.pageId(settings.pageId);
        if (settings.variationGroupId)
            this.variationGroupId(settings.variationGroupId);
        if (!utils.types.isNull(settings.timeout))
            this.timeout(settings.timeout);
        if (!utils.types.isNull(settings.waitBeforeCapture))
            this.waitBeforeCapture(settings.waitBeforeCapture);
        if (!utils.types.isNull(settings.lazyLoad))
            this.lazyLoad(settings.lazyLoad);
        if (!utils.types.isNull(settings.webview))
            this.webview(settings.webview);
    }
    /** @internal */
    static window() {
        return new this();
    }
    /** @internal */
    static region(region) {
        return new this().region(region);
    }
    /** @internal */
    static frame(contextOrFrame, scrollRootElement) {
        return new this().frame(contextOrFrame, scrollRootElement);
    }
    /** @internal */
    static shadow(selector) {
        return new this().shadow(selector);
    }
    /** @internal */
    static webview(option) {
        return new this().webview(option);
    }
    _isFrameReference(value) {
        return utils.types.isNumber(value) || utils.types.isString(value) || this._isElementReference(value);
    }
    _isRegionReference(value) {
        return utils.types.has(value, ['x', 'y', 'width', 'height']) || this._isElementReference(value);
    }
    _isElementReference(value) {
        var _a;
        const spec = (_a = this._spec) !== null && _a !== void 0 ? _a : this.constructor._spec;
        return spec.isElement(value) || this._isSelectorReference(value);
    }
    _isSelectorReference(selector) {
        var _a;
        const spec = (_a = this._spec) !== null && _a !== void 0 ? _a : this.constructor._spec;
        return (spec.isSelector(selector) ||
            utils.types.isString(selector) ||
            (utils.types.isPlainObject(selector) &&
                utils.types.has(selector, 'selector') &&
                (utils.types.isString(selector.selector) || spec.isSelector(selector.selector))));
    }
    /** @undocumented */
    name(name) {
        utils.guard.isString(name, { name: 'name' });
        this._settings.name = name;
        return this;
    }
    withName(name) {
        return this.name(name);
    }
    region(region) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        utils.guard.custom(region, value => this._isRegionReference(value), { name: 'region' });
        if (this._isSelectorReference(region) &&
            this._isSelectorReference(this._settings.region) &&
            utils.types.has(this._settings.region, 'selector')) {
            let lastSelector = this._settings.region;
            while (lastSelector.shadow)
                lastSelector = lastSelector.shadow;
            lastSelector.shadow = region;
        }
        else {
            this._settings.region = region;
        }
        return this;
    }
    shadow(selector) {
        utils.guard.custom(selector, value => this._isSelectorReference(value), { name: 'selector' });
        selector = utils.types.has(selector, 'selector') ? selector : { selector };
        if (!this._settings.region) {
            this._settings.region = selector;
        }
        else if (this._isSelectorReference(this._settings.region)) {
            let lastSelector;
            if (utils.types.has(this._settings.region, 'selector')) {
                lastSelector = this._settings.region;
                while (lastSelector.shadow)
                    lastSelector = lastSelector.shadow;
            }
            else {
                lastSelector = { selector: this._settings.region };
            }
            lastSelector.shadow = selector;
        }
        return this;
    }
    frame(contextOrFrame, scrollRootElement) {
        const context = this._isFrameReference(contextOrFrame) || this._isSelectorReference(contextOrFrame)
            ? { frame: contextOrFrame, scrollRootElement }
            : contextOrFrame;
        if (!this._settings.frames)
            this._settings.frames = [];
        utils.guard.custom(context.frame, value => this._isFrameReference(value), { name: 'frame' });
        utils.guard.custom(context.scrollRootElement, value => this._isElementReference(value), {
            name: 'scrollRootElement',
            strict: false,
        });
        this._settings.frames.push(context);
        return this;
    }
    ignoreRegion(region) {
        if (!this._settings.ignoreRegions)
            this._settings.ignoreRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.ignoreRegions.push(region);
        return this;
    }
    ignoreRegions(...regions) {
        regions.forEach(region => this.ignoreRegion(region));
        return this;
    }
    /** @deprecated */
    ignore(region) {
        return this.ignoreRegion(region);
    }
    /** @deprecated */
    ignores(...regions) {
        return this.ignoreRegions(...regions);
    }
    layoutRegion(region) {
        if (!this._settings.layoutRegions)
            this._settings.layoutRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.layoutRegions.push(region);
        return this;
    }
    layoutRegions(...regions) {
        regions.forEach(region => this.layoutRegion(region));
        return this;
    }
    strictRegion(region) {
        if (!this._settings.strictRegions)
            this._settings.strictRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.strictRegions.push(region);
        return this;
    }
    strictRegions(...regions) {
        regions.forEach(region => this.strictRegion(region));
        return this;
    }
    contentRegion(region) {
        if (!this._settings.contentRegions)
            this._settings.contentRegions = [];
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        this._settings.contentRegions.push(region);
        return this;
    }
    contentRegions(...regions) {
        regions.forEach(region => this.contentRegion(region));
        return this;
    }
    floatingRegion(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        let floatingRegion;
        if (utils.types.has(region, 'region')) {
            const { maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset, ...rest } = region;
            floatingRegion = {
                offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
                ...rest,
            };
        }
        else {
            floatingRegion = {
                region,
                offset: { top: maxUpOffset, bottom: maxDownOffset, left: maxLeftOffset, right: maxRightOffset },
            };
        }
        utils.guard.custom(floatingRegion.region, value => this._isRegionReference(value), {
            name: 'region',
        });
        utils.guard.isNumber(floatingRegion.offset.top, { name: 'maxUpOffset' });
        utils.guard.isNumber(floatingRegion.offset.bottom, { name: 'maxDownOffset' });
        utils.guard.isNumber(floatingRegion.offset.left, { name: 'maxLeftOffset' });
        utils.guard.isNumber(floatingRegion.offset.right, { name: 'maxRightOffset' });
        if (!this._settings.floatingRegions)
            this._settings.floatingRegions = [];
        this._settings.floatingRegions.push(floatingRegion);
        return this;
    }
    floatingRegions(regionOrMaxOffset, ...regions) {
        let maxOffset;
        if (utils.types.isNumber(regionOrMaxOffset)) {
            maxOffset = regionOrMaxOffset;
        }
        else {
            this.floatingRegion(regionOrMaxOffset);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.floatingRegion(region);
            else
                this.floatingRegion(region, maxOffset, maxOffset, maxOffset, maxOffset);
        });
        return this;
    }
    floating(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset) {
        if (utils.types.has(region, 'region'))
            return this.floatingRegion(region);
        else
            return this.floatingRegion(region, maxUpOffset, maxDownOffset, maxLeftOffset, maxRightOffset);
    }
    floatings(regionOrMaxOffset, ...regions) {
        return this.floatingRegions(regionOrMaxOffset, ...regions);
    }
    accessibilityRegion(region, type) {
        if (utils.types.has(region, ['left', 'top', 'width', 'height'])) {
            region = { x: region.left, y: region.top, width: region.width, height: region.height };
        }
        const accessibilityRegion = utils.types.has(region, 'region') ? region : { region, type };
        utils.guard.custom(accessibilityRegion.region, value => this._isRegionReference(value), {
            name: 'region',
        });
        utils.guard.isEnumValue(accessibilityRegion.type, AccessibilityRegionType_1.AccessibilityRegionTypeEnum, {
            name: 'type',
            strict: false,
        });
        if (!this._settings.accessibilityRegions)
            this._settings.accessibilityRegions = [];
        this._settings.accessibilityRegions.push(accessibilityRegion);
        return this;
    }
    accessibilityRegions(regionOrType, ...regions) {
        let type;
        if (utils.types.isEnumValue(regionOrType, AccessibilityRegionType_1.AccessibilityRegionTypeEnum)) {
            type = regionOrType;
        }
        else {
            this.accessibilityRegion(regionOrType);
        }
        regions.forEach(region => {
            if (utils.types.has(region, 'region'))
                this.accessibilityRegion(region);
            else
                this.accessibilityRegion(region, type);
        });
        return this;
    }
    scrollRootElement(scrollRootElement) {
        utils.guard.custom(scrollRootElement, value => this._isElementReference(value), {
            name: 'scrollRootElement',
        });
        if (this._settings.frames && this._settings.frames.length > 0) {
            const context = this._settings.frames[this._settings.frames.length - 1];
            context.scrollRootElement = scrollRootElement;
        }
        this._settings.scrollRootElement = scrollRootElement;
        return this;
    }
    fully(fully = true) {
        utils.guard.isBoolean(fully, { name: 'fully' });
        this._settings.fully = fully;
        return this;
    }
    /** @deprecated */
    stitchContent(stitchContent = true) {
        return this.fully(stitchContent);
    }
    matchLevel(matchLevel) {
        utils.guard.isEnumValue(matchLevel, MatchLevel_1.MatchLevelEnum, { name: 'matchLevel' });
        this._settings.matchLevel = matchLevel;
        return this;
    }
    layout() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Layout;
        return this;
    }
    exact() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Exact;
        return this;
    }
    strict() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Strict;
        return this;
    }
    content() {
        this._settings.matchLevel = MatchLevel_1.MatchLevelEnum.Content;
        return this;
    }
    useDom(useDom = true) {
        utils.guard.isBoolean(useDom, { name: 'useDom' });
        this._settings.useDom = useDom;
        return this;
    }
    sendDom(sendDom = true) {
        utils.guard.isBoolean(sendDom, { name: 'sendDom' });
        this._settings.sendDom = sendDom;
        return this;
    }
    enablePatterns(enablePatterns = true) {
        utils.guard.isBoolean(enablePatterns, { name: 'enablePatterns' });
        this._settings.enablePatterns = enablePatterns;
        return this;
    }
    ignoreDisplacements(ignoreDisplacements = true) {
        utils.guard.isBoolean(ignoreDisplacements, { name: 'ignoreDisplacements' });
        this._settings.ignoreDisplacements = ignoreDisplacements;
        return this;
    }
    ignoreCaret(ignoreCaret = true) {
        utils.guard.isBoolean(ignoreCaret, { name: 'ignoreCaret' });
        this._settings.ignoreCaret = ignoreCaret;
        return this;
    }
    disableBrowserFetching(disableBrowserFetching) {
        utils.guard.isBoolean(disableBrowserFetching, { name: 'disableBrowserFetching' });
        this._settings.disableBrowserFetching = disableBrowserFetching;
        return this;
    }
    layoutBreakpoints(layoutBreakpoints = true) {
        if (!utils.types.isArray(layoutBreakpoints)) {
            this._settings.layoutBreakpoints = layoutBreakpoints;
        }
        else if (layoutBreakpoints.length === 0) {
            this._settings.layoutBreakpoints = false;
        }
        else {
            this._settings.layoutBreakpoints = Array.from(new Set(layoutBreakpoints)).sort((a, b) => (a < b ? 1 : -1));
        }
        return this;
    }
    hook(name, script) {
        this._settings.hooks = { ...this._settings.hooks, [name]: script };
        return this;
    }
    beforeRenderScreenshotHook(script) {
        return this.hook('beforeCaptureScreenshot', script);
    }
    /** @deprecated */
    webHook(script) {
        return this.beforeRenderScreenshotHook(script);
    }
    ufgOption(key, value) {
        this._settings.visualGridOptions = { ...this._settings.visualGridOptions, [key]: value };
        return this;
    }
    ufgOptions(options) {
        this._settings.visualGridOptions = options;
        return this;
    }
    /** @deprecated */
    visualGridOption(key, value) {
        return this.ufgOption(key, value);
    }
    /** @deprecated */
    visualGridOptions(options) {
        return this.ufgOptions(options);
    }
    renderId(renderId) {
        utils.guard.isString(renderId, { name: 'renderId' });
        this._settings.renderId = renderId;
        return this;
    }
    pageId(pageId) {
        utils.guard.isString(pageId, { name: 'pageId' });
        this._settings.pageId = pageId;
        return this;
    }
    variationGroupId(variationGroupId) {
        utils.guard.isString(variationGroupId, { name: 'variationGroupId' });
        this._settings.variationGroupId = variationGroupId;
        return this;
    }
    timeout(timeout) {
        utils.guard.isNumber(timeout, { name: 'timeout' });
        this._settings.timeout = timeout;
        return this;
    }
    waitBeforeCapture(waitBeforeCapture) {
        utils.guard.isNumber(waitBeforeCapture, { name: 'waitBeforeCapture' });
        this._settings.waitBeforeCapture = waitBeforeCapture;
        return this;
    }
    lazyLoad(options) {
        this._settings.lazyLoad = options !== null && options !== void 0 ? options : true;
        return this;
    }
    webview(option) {
        this._settings.webview = option !== null && option !== void 0 ? option : true;
        return this;
    }
    /** @internal */
    toObject() {
        return this._settings;
    }
    /** @internal */
    toJSON() {
        return dropUndefinedProperties({
            name: this._settings.name,
            region: this._settings.region,
            frames: this._settings.frames,
            scrollRootElement: this._settings.scrollRootElement,
            fully: this._settings.fully,
            matchLevel: this._settings.matchLevel,
            useDom: this._settings.useDom,
            sendDom: this._settings.sendDom,
            enablePatterns: this._settings.enablePatterns,
            ignoreDisplacements: this._settings.ignoreDisplacements,
            ignoreCaret: this._settings.ignoreCaret,
            ignoreRegions: this._settings.ignoreRegions,
            layoutRegions: this._settings.layoutRegions,
            strictRegions: this._settings.strictRegions,
            contentRegions: this._settings.contentRegions,
            floatingRegions: this._settings.floatingRegions,
            accessibilityRegions: this._settings.accessibilityRegions,
            disableBrowserFetching: this._settings.disableBrowserFetching,
            layoutBreakpoints: this._settings.layoutBreakpoints,
            ufgOptions: this._settings.visualGridOptions,
            hooks: this._settings.hooks,
            pageId: this._settings.pageId,
            lazyLoad: this._settings.lazyLoad,
            waitBeforeCapture: this._settings.waitBeforeCapture,
            retryTimeout: this._settings.timeout,
            userCommandId: this._settings.variationGroupId,
            webview: this._settings.webview,
        });
    }
    /** @internal */
    toString() {
        return utils.general.toString(this);
    }
}
exports.CheckSettingsFluent = CheckSettingsFluent;
function dropUndefinedProperties(object) {
    return Object.entries(object).reduce((object, [key, value]) => (value !== undefined ? Object.assign(object, { [key]: value }) : object), {});
}
